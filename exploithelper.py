#!/usr/bin/env python


# Author: javiervidrua (javiervidrua) 2020
# Site: https://javiervidrua.github.io
# Credits: phillips321 (for making a python 2 and 3 compatible function)
# About: Used the function from phillips321 to create
#  a tool to make buffer overflow exploit development
#  a litlle bit easier
# Everything done by javiervidrua excep pattern_create()
########################################################


# Imports for making the code Python 2 and 3 compatible
from __future__ import print_function # print('Hello', end='') # print('Hello', file=sys.stderr)
from __future__ import division # assert 3 / 2 == 1.5 # assert 2 // 3 == 0
from future.utils import raise_with_traceback # raise_with_traceback(ValueError("dodgy value"))
import future        # pip install future
import builtins      # pip install future
import past          # pip install future
import six           # pip install six
# My imports
import sys, os, getopt, struct, codecs


# ========= #
# FUNCTIONS #
# ========= #
def interactive():
    # 1 - Create the pattern
    print(( pattern_create( int(input('[*] Pattern lenght: ')) )+'\n'))

    # 2 - Get the offset
    offset = input('[*] Enter the offset (4 bytes): ')
    offset = ('0x'+offset if '0x' not in offset else offset)
    if '0x' not in offset:
         offset = '0x' + offset
    
    offset = '69413269' # For debugging purposes
    print ('[-] Do not forget to uncomment this debugging lines!!!')
    offset = pattern_offset(offset)
    if offset == -1:
        raise Exception('[-] Error: pattern_offset: Could not find the correct offset')
    
    print('[*] The offset is: ' + offset + '\n')


# Author of the function: phillips321
# Site: www.phillips321.co.uk
# Version 0.1
# Credits: metasploit project
# About: Replicates msf pattern_create.rb (python3 compatible)
########################################################
def pattern_create(length, set_a=None, set_b=None, set_c=None):
    if not isinstance(length, int):
        raise Exception('[-] Length must be an integer')

    if not set_a: seta="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if not set_b: setb="abcdefghijklmnopqrstuvwxyz"
    if not set_c: setc="0123456789"

    string="" ; a=0 ; b=0 ; c=0
    
    while len(string) < length:
        if not set_a and not set_b and not set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and not set_b and not set_c:
            raise Exception('[-] Error: pattern_create: Cannot work with just one set!')
        elif set_a and set_b and not set_c:
            string += seta[a] + setb[b]
            b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and set_b and set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        else:
            raise Exception('[-] Error: pattern_create: Input error: Please check your parameters')

    return string[:length]


def pattern_offset(buffer, lenght=8192): # By default the lenght is 8192, but it is not fixed
    pattern = pattern_create(lenght)
    
    #string = reverse(buffer.decode('hex')) # For python2 # Reverse because it is little endian, decode.('hex') because the input value is in hexadecimal
    decode_hex = codecs.getdecoder("hex_codec")
    string = reverse( decode_hex(buffer)[0] ).decode('utf-8') # Decode the hex into bytes. Decode bytes into utf-8 (string). Reverse the string because it's in little endian.

    return str(pattern.find(string))

# Just an alias for [::-1]
def reverse(string):
    return string[::-1]


# ==== #
# MAIN #
# ==== #
if __name__ == "__main__":
    interactive() # Finish it
    # Search opcode list or something like that
    # Search opcode compiler python
    # Use getopt
    # Add GPLv2 complient things
