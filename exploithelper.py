#!/usr/bin/env python


# Author: javiervidrua (javiervidrua) 2020
# Site: https://javiervidrua.github.io
# Credits: phillips321 (for making a python 2 and 3 compatible function)
# About: Used the function from phillips321 to create
#  a tool to make buffer overflow exploit development
#  a litlle bit easier
# Everything done by javiervidrua excep pattern_create()
########################################################


# Imports for making the code Python 2 and 3 compatible
from __future__ import print_function # print('Hello', end='') # print('Hello', file=sys.stderr)
from __future__ import division # assert 3 / 2 == 1.5 # assert 2 // 3 == 0
from future.utils import raise_with_traceback # raise_with_traceback(ValueError("dodgy value"))
import future        # pip install future
import builtins      # pip install future
import past          # pip install future
import six           # pip install six
# My imports
import sys, os, getopt, struct, codecs


# ========= #
# FUNCTIONS #
# ========= #
def printReturnAddressInstructions():
    print('\t1 - Search the modules:')
    print('\t\t* Imunnity Debugger: !mona modules')
    print('\t\t* Evans\' debugger: Plugins -> Opcode search')
    print('\t2 - Choose a module that hasn\'t got any security measures (DEP, ASLR, Rebase,...) enabled')
    print('\t3 - Get the opcode of the instructions you want')
    print('\t4 - Search the chosen module for that instruction:')
    print('\t\t* Imunnity Debugger: !mona find -s "\\xOPCODE" -m MODULE')
    print('\t\t* Evans\' debugger: Plugins -> Opcode search -> Select the module you want to search in')
    print('\t5 - Get the return address of the chosen instruction and use it in your exploit\n')


def generateBadchars():
    return ("""badchars=(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"
\"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"
\"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"
\"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"
\"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"
\"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"
\"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"
\"\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\"
\"\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\"
\"\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\"
\"\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\"
\"\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\"
\"\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\"
\"\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\"
\"\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\"
\"\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\")\n""")


def interactive():
    # 1 - Create the pattern
    print(( pattern_create( int(input('[*] Pattern lenght: ')) )+'\n'))

    # 2 - Get the offset
    offset = input('[*] Enter the offset (4 bytes): ')
    offset = ('0x'+offset if '0x' not in offset else offset)
    #if '0x' not in offset:
    #     offset = '0x' + offset
    offset = '69413269' # For debugging purposes
    print ('[-] Do not forget to uncomment this debugging lines!!!')
    offset = pattern_offset(offset)
    if offset == -1:
        raise Exception('[-] Error: pattern_offset: Could not find the correct offset')
    print('[*] The offset is: ' + offset + '\n')

    # 3 - Get the badchars
    print ('[*] Printing badchars ready to paste on Python code')
    print (generateBadchars())

    # 4 - Get a return address
    print ('[*] Printing how to find a return address')
    printReturnAddressInstructions()


# Author of the function: phillips321
# Site: www.phillips321.co.uk
# Version 0.1
# Credits: metasploit project
# About: Replicates msf pattern_create.rb (python3 compatible)
########################################################
def pattern_create(length, set_a=None, set_b=None, set_c=None):
    if not isinstance(length, int):
        raise Exception('[-] Length must be an integer')

    if not set_a: seta="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if not set_b: setb="abcdefghijklmnopqrstuvwxyz"
    if not set_c: setc="0123456789"

    string="" ; a=0 ; b=0 ; c=0
    
    while len(string) < length:
        if not set_a and not set_b and not set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and not set_b and not set_c:
            raise Exception('[-] Error: pattern_create: Cannot work with just one set!')
        elif set_a and set_b and not set_c:
            string += seta[a] + setb[b]
            b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        elif set_a and set_b and set_c:
            string += seta[a] + setb[b] + setc[c]
            c+=1
            if c == len(setc):c=0;b+=1
            if b == len(setb):b=0;a+=1
            if a == len(seta):a=0
        else:
            raise Exception('[-] Error: pattern_create: Input error: Please check your parameters')

    return string[:length]


def pattern_offset(buffer, lenght=8192): # By default the lenght is 8192, but it is not fixed
    pattern = pattern_create(lenght)
    
    #string = reverse(buffer.decode('hex')) # For python2 # Reverse because it is little endian, decode.('hex') because the input value is in hexadecimal
    decode_hex = codecs.getdecoder("hex_codec")
    string = reverse( decode_hex(buffer)[0] ).decode('utf-8') # Decode the hex into bytes. Decode bytes into utf-8 (string). Reverse the string because it's in little endian.

    return str(pattern.find(string))


# Just an alias for [::-1]
def reverse(string):
    return string[::-1]


# ==== #
# MAIN #
# ==== #
if __name__ == "__main__":
    interactive() # Finish it
    # Search opcode list or something like that
    # Search opcode compiler python
    # Use getopt
    # Add GPLv2 complient things
